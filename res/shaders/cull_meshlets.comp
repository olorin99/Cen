#version 460

#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

#include "shaders/cen.glsl"

layout (push_constant) uniform Push {
    GlobalDataRef globalDataRef;
    MeshletBuffer meshletBuffer;
    MeshletInstanceBuffer meshletInstanceInputBuffer;
    MeshletInstanceBuffer meshletInstanceOutputBuffer;
    TransformsBuffer transformsBuffer;
    CameraBuffer cameraBuffer;
};

bool frustumCheck(vec3 pos, float radius) {
    GPUCamera cullingCamera = cameraBuffer[globalDataRef.globalData.cullingCamera].camera;

    for (int i = 0; i < 6; i++) {
        if (dot(vec4(pos, 1.0), cullingCamera.frustum.planes[i]) + radius < 0.0) {
            return false;
        }
    }
    return true;
}

layout (local_size_x = 64) in;
void main() {

    uint threadIndex = gl_GlobalInvocationID.x;
    if (threadIndex >= globalDataRef.globalData.maxMeshletCount)
        return;

    bool visible = false;
    if (threadIndex < meshletInstanceInputBuffer.count) {
        MeshletInstance instance = meshletInstanceInputBuffer.instances[threadIndex];
        Meshlet meshlet = meshletBuffer.meshlets[instance.meshletId];
        vec3 center = (transformsBuffer.transforms[instance.meshId] * vec4(meshlet.center, 1.0)).xyz;
        visible = frustumCheck(center, meshlet.radius);
        atomicAdd(globalDataRef.globalData.feedbackInfoRef.info.meshletsTotal, 1);
        if (visible) {
            uint index = atomicAdd(meshletInstanceOutputBuffer.count, 1);
            atomicAdd(globalDataRef.globalData.feedbackInfoRef.info.meshletsDrawn, 1);
            meshletInstanceOutputBuffer.instances[index] = instance;
        }
    }
}
