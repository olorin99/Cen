#version 460

#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_mesh_shader : enable

#include "shaders/cen.glsl"

#ifndef WORKGROUP_SIZE_X
#define WORKGROUP_SIZE_X 64
#endif

#define MAX_VERTICES_PER_THREAD ((MAX_MESHLET_VERTICES + WORKGROUP_SIZE_X - 1) / WORKGROUP_SIZE_X)
#define MAX_PRIMITIVES_PER_THREAD ((MAX_MESHLET_PRIMTIVES + WORKGROUP_SIZE_X - 1) / WORKGROUP_SIZE_X)

layout (location = 0) out VsOut {
    flat uint drawId;
    flat uint meshletId;
} meshOut[];

layout (push_constant) uniform Push {
    GlobalDataRef globalDataRef;
    MeshletBuffer meshletBuffer;
    MeshletInstanceBuffer meshletInstanceBuffer;
    VertexBuffer vertexBuffer;
    IndexBuffer indexBuffer;
    PrimitiveBuffer primitiveBuffer;
    TransformsBuffer transformsBuffer;
    CameraBuffer cameraBuffer;
};

layout (local_size_x = WORKGROUP_SIZE_X) in;
layout (triangles, max_vertices = MAX_MESHLET_VERTICES, max_primitives = MAX_MESHLET_PRIMTIVES) out;
void main() {

    uint threadIndex = gl_LocalInvocationIndex;

    GPUCamera camera = cameraBuffer.camera;

    uint meshletIndex = gl_WorkGroupID.x + gl_NumWorkGroups.x * gl_WorkGroupID.y;
    if (meshletIndex >= meshletInstanceBuffer.count) {
        SetMeshOutputsEXT(0, 0);
        return;
    }
    MeshletInstance instance = meshletInstanceBuffer.instances[meshletIndex];
    Meshlet meshlet = meshletBuffer.meshlets[instance.meshletId];

    SetMeshOutputsEXT(meshlet.indexCount, meshlet.primitiveCount);

    if (threadIndex == 0) {
        atomicAdd(globalDataRef.globalData.feedbackInfoRef.info.trianglesDrawn, meshlet.primitiveCount);
    }

    for (uint i = 0; i < MAX_VERTICES_PER_THREAD; i++) {
        const uint id = min(threadIndex + i * WORKGROUP_SIZE_X, meshlet.indexCount - 1);
        uint index = indexBuffer.indices[meshlet.indexOffset + id] + meshlet.vertexOffset;
        Vertex vertex = vertexBuffer.vertices[index];
        vec4 fragPos = transformsBuffer.transforms[instance.meshId] * vec4(vertex.position, 1.0);

        meshOut[threadIndex].drawId = instance.meshId;
        meshOut[threadIndex].meshletId = instance.meshletId;

        gl_MeshVerticesEXT[threadIndex].gl_Position = camera.projection * camera.view * fragPos;
    }

    for (uint i = 0; i < MAX_PRIMITIVES_PER_THREAD; i++) {
        uint id = min(threadIndex + i * WORKGROUP_SIZE_X, meshlet.primitiveCount - 1);
        uint a = primitiveBuffer.primitives[meshlet.primitiveOffset + id * 3 + 0];
        uint b = primitiveBuffer.primitives[meshlet.primitiveOffset + id * 3 + 1];
        uint c = primitiveBuffer.primitives[meshlet.primitiveOffset + id * 3 + 2];

        gl_PrimitiveTriangleIndicesEXT[id] = uvec3(a, b, c);
        gl_MeshPrimitivesEXT[id].gl_PrimitiveID = int(id);
    }
}