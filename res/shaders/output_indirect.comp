#version 460

#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

#include "shaders/cen.glsl"

#ifndef WORKGROUP_SIZE_X
#define WORKGROUP_SIZE_X 64
#endif

#define MAX_VERTICES_PER_THREAD ((MAX_MESHLET_VERTICES + WORKGROUP_SIZE_X - 1) / WORKGROUP_SIZE_X)
#define MAX_PRIMITIVES_PER_THREAD ((MAX_MESHLET_PRIMTIVES + WORKGROUP_SIZE_X - 1) / WORKGROUP_SIZE_X)

struct DrawIndirectCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};
layout (scalar, buffer_reference, buffer_reference_align = 4) writeonly buffer DrawCommandBuffer {
    uint drawCount;
    DrawIndirectCommand commands[];
};

layout (push_constant) uniform Push {
    GlobalDataRef globalDataRef;
    MeshletBuffer meshletBuffer;
    MeshletInstanceBuffer meshletInstanceBuffer;
    PrimitiveBuffer primitiveBuffer;
    MeshletIndexBuffer meshletIndexBuffer;
    DrawCommandBuffer drawCommandBuffer;
};

shared uint sharedIndexOffset;

layout (local_size_x = WORKGROUP_SIZE_X) in;
void main() {

    uint threadIndex = gl_LocalInvocationIndex;
    if (threadIndex == 0) {
        sharedIndexOffset = 0;
    }
    barrier();

    uint meshletIndex = gl_WorkGroupID.x + gl_NumWorkGroups.x * gl_WorkGroupID.y;
    if (meshletIndex >= meshletInstanceBuffer.count) {
        return;
    }

    MeshletInstance instance = meshletInstanceBuffer.instances[meshletIndex];
    Meshlet meshlet = meshletBuffer.meshlets[instance.meshletId];

    if (threadIndex == 0) {
        sharedIndexOffset = atomicAdd(meshletIndexBuffer.indexCount, meshlet.primitiveCount * 3);

    }
    barrier();
    if (sharedIndexOffset >= globalDataRef.globalData.maxIndirectIndexCount)
        return;
    barrier();

    if (threadIndex == 0) {
        atomicAdd(globalDataRef.globalData.feedbackInfoRef.info.trianglesDrawn, meshlet.primitiveCount);
        uint drawIndex = atomicAdd(drawCommandBuffer.drawCount, 1);
        DrawIndirectCommand drawCommand;
        drawCommand.vertexCount = meshlet.primitiveCount * 3;
        drawCommand.firstVertex = sharedIndexOffset;
        drawCommand.instanceCount = 1;
        drawCommand.firstInstance = 0;
        drawCommandBuffer.commands[drawIndex] = drawCommand;
    }

    for (uint i = 0; i < MAX_PRIMITIVES_PER_THREAD; i++) {
        uint id = min(threadIndex + i * WORKGROUP_SIZE_X, meshlet.primitiveCount - 1);

        uint a = primitiveBuffer.primitives[meshlet.primitiveOffset + id * 3 + 0];
        uint b = primitiveBuffer.primitives[meshlet.primitiveOffset + id * 3 + 1];
        uint c = primitiveBuffer.primitives[meshlet.primitiveOffset + id * 3 + 2];

        uint indexOffset = sharedIndexOffset + id * 3;
        meshletIndexBuffer.indices[indexOffset + 0] = setMeshletID(meshletIndex) | setPrimitiveID(a);
        meshletIndexBuffer.indices[indexOffset + 1] = setMeshletID(meshletIndex) | setPrimitiveID(b);
        meshletIndexBuffer.indices[indexOffset + 2] = setMeshletID(meshletIndex) | setPrimitiveID(c);
    }

}
